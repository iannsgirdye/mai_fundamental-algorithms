# Работа №3, задача №3

Реализуйте библиотеку, предоставляющую пользователю функционал двусвязного списка (`LinkedList`) для типа `Liver`.
Требуется реализовать следующие функции. На его основе решите эту задачу.

В текстовом файле находится информация о жителях (тип структуры `Liver`) некоторого поселения:
- **id** жителя (неотрицательное значение, которое неизменно в течении работы программы);
- фамилия (непустая строка только из букв латинского алфавита);
- имя (непустая строка только из букв латинского алфавита);
- отчество (строка только из букв латинского алфавита; допускается пустая строка);
- дата рождения (в формате число, месяц, год);
- пол (символ `M` — мужской, символ `W` — женский);
- средний доход за месяц (неотрицательное вещественное число).

Напишите программу, которая считывает эту информацию из файла в двусвязный упорядоченный список
(в порядке увеличения возраста). Информация о каждом жителе должна храниться в объекте структуры `Liver`.
Реализуйте возможности:
- поиска жителя с заданными параметрами;
- изменение существующего жителя списка;
- удаления / добавления информации о жителях;
- выгрузку данных из списка в файл (путь к файлу запрашивайте у пользователя с консоли);
- отменить последние `N/2` введённых модификаций, то есть аналог команды `Undo`
(`N` — общее количество модификаций на текущий момент времени с момента чтения файла 
или последней отмены введённых модификаций).

## Двусвязный список
Узел
``` c
typedef struct Node {
  double *data;
  struct Node *prev;
  struct Node *next;
} Node;
```

Двусвязный список
``` c
typedef struct {
  Node *head; 
  Node *tail;
  size_t size;
} LinkedList;
```

Создание пустого списка
``` c
LinkedList create_list(void);
```

Очистка содержимого списка (удаление всех элементов) 
``` c
void erase_list(LinkedList *list);
```

Полное удаление списка (освобождение ресурсов)
``` c
void delete_list(LinkedList *list);
```

Добавление элемента в конец списка
``` c
void push_back_list(LinkedList *list, LIST_TYPE value);
```

Добавление элемента в начало списка
``` c
void push_front_list(LinkedList *list, LIST_TYPE value);
```

Удаление элемента с конца списка
``` c
double pop_back_list(LinkedList *list);
```

Удаление элемента с начала списка
``` c
double pop_front_list(LinkedList *list);
```

Вставка элемента по индексу
``` c
void insert_at_list(LinkedList *list, size_t index, LIST_TYPE value);
```

Удаление элемента по индексу
``` c
void delete_at_list(LinkedList *list, size_t index);
```

Получение элемента по индексу
``` c
double get_at_list(const LinkedList *list, size_t index);
```

Сравнение двух списков (лексикографически): возвращает `1` — равны, `0` — не равны
``` c
int is_equal_list(const LinkedList *l1, const LinkedList *l2);
```


## Стек
Поместить элемент на вершину стека
``` c
void push_stack(LinkedList *stack, LIST_TYPE value);
```

Извлечь элемент с вершины стека
``` c
double pop_stack(LinkedList *stack);
```

Получить элемент с вершины стека без удаления
``` c
double peek_stack(const LinkedList *stack);
```


## Очередь
Добавить элемент в очередь
``` c
void enqueue(LinkedList *queue, LIST_TYPE value);
```

Извлечь элемент из очереди
``` c
double dequeue(LinkedList *queue);
```

Получить первый элемент очереди без удаления
``` c
double peek_queue(const LinkedList *queue);
```
