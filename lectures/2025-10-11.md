# Лекция №3 (2025.10.11)
## Объединение
Тип данных, похожий на структуру, но отличается тем, что поля лежат в одной области памяти.
Занимает столько места, сколько занимает наибольшее поле.
```c
union MyUn {
  int x;
  float
};

union MyUn u1;
u1.f = -1.5;
u1.x = 1000;
```


## Определение действия
Заменять больше трёх `if` или `switch-case` на массив указателей на функции.


## Абстрактные типы данных
*(aka динамические типы данных / самоссылочные типы данных)*

- Односвязный (однонаправленный) список
- Двусвязный (двунаправленный) список
- Очередь
- Стек


### Операции над коллекцией
- Добавление элемента
- Удаление элемента
- Поиск элемента
- Доступ к элементу
- Создание элемента коллекции


### Узел
``` c
struct Node {
  int data;
  struct Node *pNext;
};

struct Node *Create(int data) {
  struct Node *ptr = NULL;
  ptr = (struct Node *)malloc(sizeof(struct Node));  // не забыть проверить успешность выделения памяти
  ptr->pNext = NULL;
  /* Во всех коллекция лучше хранить адрес на данные,
  а не сами данные, чтобы не тратить время на копирование */
  ptr->data = data;
}
```


### Односвязный список
**Посещение всех элементов**
``` c
struct Node *pHead;  
// в этой строке корректная инициализация pHead

while (pHead != NULL) {
  printf("%d\n", pHead->data);
  pHead = pHead->pNext;
}
```

**Добавление элемента в начало**
``` c
pHead  // определён
pNew   // указатель на добавленный элемент

pNew->pNext = pHead;
pHead = pNew;
```

**Добавление элемента в середину**
Найти с помощью линейного поиска или знать адрес элемента, после которого будет вставлен элемент
``` c
ptr  // указатель на узел списка, после которого необходимо вставить добавить новое звено
pNew->pNext = ptr->pNext;
ptr->pNext = pNew;
```

**Добавление элемента в конец**
``` c
while (pHead->Next != NULL) {
  pHead = pHead->Next;
}
pHead->Next = pNew;
```

**Удаление элемента из начала**
```c
ptr = pHead;
phead = phead->pNext
free(ptr)
```

**Удаление элемента из середины**
```c
ptr  // указатель перед удаляемым элементов
rptr = ptr->pNext;
ptr->pNext = rptr->pNext;
free(rptr);
```


### Стек
**Канонические операции:**
- `push` - добавить элемент на вершину
- `pop` - удалить элемент с вершины и удалить его

**Дополнительные операции:**
- `peek` - посмотреть элемент на вершины стека


**Стек на основе односвязного списка**
- `push` - добавление элемента в начало
- `pop` - удаление элемента из начала


### Алгоритм Дейкстры
Перевод арифметического выражения из инфиксной формы в постфиксную 
| Вход | Выход |
|---|---|
| строка с арифметическим выражением | строка в качестве результата преобразования |

Пока не кончились символы в входной строке:
- если текущий символ является символом цифры, то добавление к выходной строке;
- если текущий символ `'('`, то заносим её в стек;
- если текущий символ `')'`, то до тех пор, пока на вершине не окажется открывающаяся скобка, выталкивать элементы из стека в выходную строку, но открывающую скобку в выходную строку не пишем, а отбрасываем;
- если текущий символ является символом операции и приоритет текущей операции меньше либо равен приоритета операции на вершине стека, то выталкиваем из стека операции в выходную строк, а саму операцию заталкиваем в стек.

**Примеры**
| Номер | Вход | Выход |
|---|---|---|
| 1 | `1 + 4/2 * 3` | `1 4 2 / 3 * +` |
| 2 | `3 + 4 * (2 - 1)` | `3 4 2 1 - * +` |
| 3 | `(2 + ((1 + 2) / 4 + 5) [*] 6 / (4 + 6 - 4 + 8 - 1)) * 8 + 2` | `2 1 2 + 4 / 5 + 6 * 4 6 + 4 - 8 + 1 - / + 8 * 2 +` |
