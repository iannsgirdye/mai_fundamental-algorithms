# Лекция №4 (2025.10.25)

## Дерево
Сложность поиска в дереве $O(log n)$, если оно не превращается список, то есть у каждого узла только 1 потомок, так как каждый раз отбрасывается половина дерева при проходу по узлам.

Двоичное дерево — динамическая структура данных.


### Построение дерева арифметического выражения
- Вход: арифметическое выражение в виде строки
- Выход: указатель на корень дерева
- Стек 1: операции, то есть $*/+-($
- Стек 2: операнды, то есть указатели на узлы бинарного дерева (стек деревьев).
- Узел дерева:
  - информация об операции или операнде (объединение)
  - `pleft`
  - `pright`

Условие: односимвольные имена переменных


Пока не конец формулы:
  - Если текущий символ — буква или значение константы (т.е. операнд), то <br/>
    создаётся узел дерева, в который помещается этот операнд <br/>
    указатели на левое и правое поддеревья ставятся в `NULL` <br/>
    и указатель на созданный узел помещается в стек операндов.
  - Если текущий символ - `'('`, то заносим его в стек операций.
  - Если текущий символ - `'+'`/`'-'`/`'*'`/`'/'`:
    - если стек операций не пуст, то 
      - если приоритет анализируемой текущей операции больше приоритета операции на вершине стека, <br/>
        то операция заносится в стек. 
      - иначе начало цикла: <br/>
        создаём узел дерева, в который помещается знак операции, указатель на правое поддерево берётся с вершины стека операндов, а указатель на левое поддерево также берётся с вершины стека операндов.  <br/>
        Обработанные операнды выбрасываются из стека, указатель на созданный узел дерева заносится в стек. <br/>
        Повторять эти действия до тех пор, пока приоритет обрабатываемой операции не станет больше приоритета операции на вершине стека или стек не станет пустым. <br/>
        Знак обрабатываемой операции помещается в стек операций.
  - Если текущий символ - `')'`, то <br/>
    создаём новый узел дерева, в значение которого помещается знак операции из вершины стека операций - указатели на правое и левое поддеревья берутся из стека операндов.

  Повторять эти шаги до тех пор, пока на вершине стека операций не появится открывающаяся скобка. Найденная открывающаяся скобка отбрасывается.

  - Если текущий символ - символ конца формулы, то 
    если стек операций не пуст, то создаём новый узел дерева, в поле данных которого помещается знак операции из вершины стека, а указатели на правое и левое поддеревья соответственно - элементы из стека операндов. Обработанные операнды выкидываются из стека, а указатель на новый узел заносится в стек операндов. Повторять этот шаг до тех пор, пока стек операций не станет пустым.


**Пример**
`(a * b)/(c - (d + e))`

```
            [ / ]
         ___/   \___
    [ * ]           [ - ]
    /   \           /   \
[ a ]   [ b ]   [ c ]   [ + ]
                        /   \
                    [ d ]   [ e ]
```


(фотографии)


### Двоичные деревья
``` c
struct TreeNode {
  Data data;
  struct TreeNode *pleft;
  struct TreeNode *pright;
}
```

Канонические операции:
- вставка/добавление элемента
- поиск элемента, посещение элементов
- удаление элемента


``` c
void WalkTree(struct TreeNode *pRoot) {
  if (pRoot == NULL) {
    return;
  }

  WalkTree(pRoot->pleft);
  printf("Data\n"); // обработка элемента текущего узла
  WalkTree(pRoot->pRight);
}
```

Создать тестовое бинарное дерево из интов, заполнить как-то, походить, печатая элемент. Менять местами проход по узлам и печать местами (последние три строки функции), чтобы увидеть что будет, если менять местами их.


**Алгоритм поиска со вставкой по бинарному дереву ("либо нашли, либо не нашли, вставили и сразу же нашли")**
``` c
void FindAndInsert(struct TreeNode **pRoot, Data value) {
  struct TreeNode *ptr = *pRoot;
  
  if (*pRoot == NULL) { // пришло пустое дерево
    *pRoot = (struct TreeNode)malloc(sizeof(struct TreeNode));
    // пренебрегаем проверкой на NULL от malloc()
    *pRoot->data = value;
    *pRoot->pLeft = NULL;
    *pRoot->pRight = NULL;
    return;
  }
  
  // далее дерево точно не пусто, теперь проверяем есть ли уже элемент
  if (ptr->data == value) {
    printf("Exists!\n");
    return;
  }
  if (value < ptr->data) {
    FindAndInsert(&ptr->pLeft, value);
  }
  if (value > ptr->data) {
    FindAndInsert(&ptr->pRight, value);
  }
}
```
