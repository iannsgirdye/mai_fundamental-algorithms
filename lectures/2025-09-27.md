# Лекция №2 (2025.09.27)
## Работа с файлами
```c
fopen()
fclose()
fgetc()
fgets()
fputc()
fputs()
fscanf()
fprintf()
```

```c
FILE *fi = NULL;
char buff[BUFSIZ];
char ch, pch = 0 // перед началом чтения прошлого символа нет
char *ptr = buff;

if ((fi = fopen("1.txt", "r")) == NULL) {
  perror("Error!");  // Сначала сама ОС скажет, что пошло не так, потом выведется сообщение
                     // не всегда уместно использовать
  return -1;
}

while ((ch = fgetc(fi)) != EOF) {
  if (isalnum(ch)) {
    *ptr++ = ch;  // сначала записали, потом передвинули
  } else if (isalnum(pch)) {
    *ptr = '\0';           // закрытие буфера
    printf("%s\n", buff);  // вывод буфера
    ptr = buff;            // очистка буфера
  }
  pch = ch;
}

// (здесь нужно обработать последний символ). Вариант получше:
do {
  ch = fgetc(fi);
  ...
  pch = ch;
} while (ch! = EOF);

// ещё вариант:
while (!feof(fi)) {  // для решения при чтении строк и символов.
  ...
}

fclose(fi);
```


## Функции
Блок кода

В языке Си парадигма структурного рпограммированяе — дробление программы на функции
для их последующего последовательного вызова.

Конечное количество аргументов
<ut_type> F_Name(<type 1> p1, <type 2> p2, <type N> > pN) {}

`static` переменные хранятся в области данных, локальные переменные — в области стека.


### Способы передачи аргументов
**Аргументы передаются по значению**
```c
int foo(int x) {
  x *= 10;
  return 2 + x;
}


int foo1(int *pint) {
  *pint *= 10;
  return 2 + *pint;
}


int main() {
  int y = 5;
  int z;
  z = foo(y);    // без модификации "игрека"
  z = foo1(&y);  // модификация "игрека"

  return 0;
}
```

**Неопределённое поведение**
```c
int n = 10;
printf("%d %d %d\n", n++, n++, n++);  // результат зависит от компилятора
```


## `const`
- неконстантный указатель на неконстантную переменную
- неконстантный указатель на константную переменную
- константный указатель на неконстантную переменную
- константный указатель на константную переменную


## Динамическая память
```c
malloc()   // ожидает размер памяти в байтах, выделяет муссор
calloc()   // аналогичен malloc(), но инициализирует все байты нулями
realloc()
free()
```
- Возращают `(void *)`, чтобы привести к нужному типу
- `sizeof()` используется для определения размера памяти
- указатель, возвращаемый из `realloc()` должен сохраняться во временную переменную,
чтобы не утерять изначальную память (утечка)

**Считать с клавиатуры неизвестное количество строк длиной не больше BUFSIZ,**
**сохранить в динамический массив, вывести его на экран**

Варианты решения:
- увеличение размера массива на 1
- увеличение количества элементов в 2 раза (нужно всегда реализовывать)

``` c
char **array = NULL;  // массив полученных строк
char buff[BUFSIZ];    // буфер для хранения последней полученной строки
int count = 0;        // количество полученных строк
int i = 0;

```


## Переменное число аргументов в функции
```c
#include <strlib.h>
#include <stdarg.h>
<ret_type> Foo(<type1> p1, <type2> p2, ...) {
  va_list p;
  va_start(p, p2);
  va_arg(p, <type>);
  va_end(p);
}
```
Нужно понимать, сколько будет передано агрументов в `...`, иначе непредвиденное поведение.


## Коллекции
Нужно понимать порядок доступа (для чтения и поиска), добавления и удаления элементов коллекции.


| Структура данных | Описание | Сложности |
|---|---|---|
| Массив | данные в памяти идут подряд | - поиск — $O(logn)$ для неотсортированного, $O(n)$ для противного; <br/> - добавление — линейная; <br/> - удаление — $O(n)$ |
| Односвязный список | состоит из узлов, в каждой из которых содержат данные и указатель на следующий элемент | ... |
