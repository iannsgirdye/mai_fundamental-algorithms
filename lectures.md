# Фундаментальные алгоритмы
aka качалка

## Лекция 2025.09.13
### `int main();`
- Точка входа в программу
- Если вернула число, отличное от `0`, ОС отреагирует

### `printf();`
- функция с переменным количеством аргументов;
- возвращает количество символов, выведенных в консоль.

### Переменные
- При объявлении без определения в памяти хранится мусор;
- Глобальные переменные инициализируются с нулевым значением, локальные — нет;
- Рекомендуется избегать глобальных переменных.

### Целочисленные типы данных
`char`, `int`, `short`, `long`, `unsigned char`, `unsigned` 

- Если переменная знаковая, то первый бит отвечает за знак, остальные — за число, в противнмо случае — все биты отвечают за число.
- Отрицательное число хранится в памяти как инвертированное положительное число `+ 1` <br/>
Например: `1 = 00000001`, тогда `-1 = 11111110 + 1 = 11111111` — дополнительный код.

### Арифметические операции
Изучить все операторы (фото 2025.09.13 14:10)

### Инкремент и декримент
- `--x`, `++x` — сначала модификация, потом использование
- `x--`, `x++` — сначала использование, потом модификация
Не используются с вещественными типами данных

### Вещественные типы данных
`float`, `double`

**Сравнение**
``` c
#define EPSILON 0.000001
float x, y;
abs(x - y) <= EPSILON;
```

### Массив
Набор однотипных переменных, которые располагаются в памяти рядом, благодаря чему есть индексация. <br/>
- `char x[50]` — статический массив
- `x` хранит в себе указатель на первый элемент массива, т.е. `*x = x[0]`, `char* px = x`.
- нельзя использовать `sizeof();` для массива, так как значение всегда будет равно `4`, потому что название массива — указатель на его первый элемент.

### Строковый тип данных
- Строка — массив символов, который оканчивается на `\0`.
- `string.h` — библиотека для работы со строками, в которой функции называются с `str-`.
- `strcmp()`: `-1`, если 1-я строка меньше 2-й; `0`, если равны; `1`, если 1-я строка больше 2-й.

### Указатели
Указатель - переменная, значением которой является адрес ячейки памяти. <br/>
Размер указателя = `4` байта.
``` c
int a;
int* x;
char* pch;
double * pd;
```

- `x = &a` — сохранение адреса переменной `a`
- `*x = 100` — разыменование указателя: в ячейку памяти, на которую указывает `x`, записать значение `100`
- `x = x + 1` — увеличение числа адреса на `4`, так как `int = 4` байта
`(x*)++` — увеличение значения ячейки с адресом `x` на `1`

### Перевод из строки в число
(фото 15:18 2025.09.13)


### Схема Горнера
``` tex
f(x) = f_0 + f_1x + f_2x^2 + f_3x^3 + ... + f_nx^n = 
f_0 + x(f_1 + f_2x + f_3x^2 + f_nx^{x - 1}) =
f_0 + x(f_1 + x(f_2 + ...(...x(f_{n - 1} + f_nx))))
```

количество умножений = `n`, так как удаётся вынести ровно `n` раз `x`

``` c
int main() {
  char st = "12345";
  int base = 10;
  int res = 0;
  char *p = st;
  while (*p) {
    res = res * base + (isdigit(*p) ? *p - '0' : *p - 'A' + 10);
    p++;
  }

  return 0;
}

// когда *p = '\0', то цикл завершится, так как символ конца строки является нулём
```


### Перевод из числа в строку (из 10СС в заданную)
``` c
#define SIZE 2

int main() {
  char buf[SIZE];
  char *p = buf + SIZE - 1;
  int n = 12345, base = 20, r;

  while (n) {  // пока есть число
    r = n % base;
    if (p > 9) {
      *p-- = r - 10 + 'A', 
    } else {
      *p-- = r + '0';
    }
    n /= base;
  }

  *p-- = 0;

  printf("%s\n", p + 1);

  return 0;
}
```


### Файл
- Последовательность байтов (неважно, где находится)
- Порядок действий: открываем файл, проводим работу с ним, закрываем файл.
- При работе с файлами нужно использовать функции с префиксом `f-`. Те же самые функции без этого префикса предназначены для работы на нижнем уровне.

``` c
FILE* fi = NULL;  // FILE* - структура типа файл, которая описывает сам файл
if (!fi = fopen("1.txt", "r")) {
  printf("Bad file!\n");
  return 1;
}
fclose(fi);
```

Анонс следующего разговора:
- Как вычлинять лексемы
- Как вычлинять слова
- Что такое функция
- Способы передачи аргументов
- Функции с переменным числом аргументов
- что-то ещё (1-2 пункта)
